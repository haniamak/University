#!/usr/bin/python3

import rsa.rsa as rsa
import rsa.pkcs15pad as pad
from rsa.oracle import Oracle
from sys import argv

keyFile = 'bleichenbacher/RSAkey1'
ciphertextFile = 'bleichenbacher/cipher1.txt'

print("""All you need is the encryption key, the eavesdropped ciphertext,
and the oracle. The oracle needs the private key, so in fact the key
we read here is private. Pretend you do not have access to the private
part!""")

key = rsa.read(keyFile)
with open(ciphertextFile) as cf:
    ciphertext = int(cf.readline().strip())
oracle = Oracle(key).simpleOracle

print('This is your key of size {} bits ({} bytes):'.format
         (key.keyBits, key.keyBytes))
print('n =', key.n)
print('e =', key.e)
print('ciphertext =', ciphertext)
print('oracle =', oracle)
print('Now is YOUR turn!')

def floor(a, b):
    return a // b


def ceil(a, b):
    return a // b + (a % b > 0)

B = 2 **(8 * (key.keyBytes - 2))
a0 = 2 * B
b0 = 3 * B - 1

s0 = ceil((key.n + a0), b0)
M0 = set([(a0, b0)])

print(M0)

def bleichenbacher_step1(lowerbound):
    s = lowerbound
    while True:
        new_ciphertext = (pow(s, key.e, key.n) * ciphertext) % key.n
        if oracle(new_ciphertext) == pad.ErrorCode.SUCCESS:
            return s
        s = s + 1
        # print('Trying s =', s)

# s1 = s0
# while True:
#     s1 = bleichenbacher_step1(s1)
#     print('Found s1 =', s1)

def bleichenbacher_step1opt(s, a, b):
    r = ceil(2 * (b * s - a0), key.n) # to 2 razy do zastanowienia
    while True:
        low_bound = ceil((a0 + r * key.n), b)
        high_bound = floor((b0 + r * key.n), a)
        for s in range(low_bound, high_bound + 1):
            new_ciphertext = (pow(s, key.e, key.n) * ciphertext) % key.n
            if oracle(new_ciphertext) == pad.ErrorCode.SUCCESS:
                return s
            
        r = r + 1
        
def bleichenbacher_step2(s, M):
    new_M = set()
    for (a, b) in M:
        r_min = ceil((a * s - 3 * B + 1), key.n)
        r_max = floor((b * s - 2 * B), key.n)
        for r in range(r_min, r_max + 1):
            new_a = max(a, ceil(2 * B + r * key.n, s))
            new_b = min(b, floor(3 * B - 1 + r * key.n, s))
            if new_a <= new_b:
                new_M.add((new_a, new_b))
    return new_M

s0 = bleichenbacher_step1(s0)
print('Found s =', s0)
M0 = bleichenbacher_step2(s0, M0)
print('M0 =', M0)

while True:
    if len(M0) > 1:
        s0 = bleichenbacher_step1(s0)
        print('Found s0 =', s0)
    else:
        interval = M0.pop()
        M0.add(interval)
        if interval[0] == interval[1]:
            print('Found plaintext:', interval[0])
            EB = interval[0].to_bytes(key.keyBytes, byteorder='big')
            message = pad.dec(EB)
            print('Message:', message.decode('utf-8'))
            break
        s0 = bleichenbacher_step1opt(s0, interval[0], interval[1])
        print('Found s0 (opt) =', s0)


    M0 = bleichenbacher_step2(s0, M0)
    print('M0 =', M0)
    if not M0:
        print("ERROR: M0 is empty")
        break
