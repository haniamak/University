## Jakie mamy możliwości optymalizacji rozmiaru obrazu Dockera?

- Używanie lekkich bazowych obrazów, takich jak Alpine Linux zamiast pełnych dystrybucji.
- Łączenie instrukcji RUN w Dockerfile, aby zmniejszyć liczbę warstw.
- Używanie .dockerignore, aby wykluczyć niepotrzebne pliki i katalogi z kontekstu budowania.
- Czyszczenie cache pakietów

## Co się stanie z rozmiarem obrazu, jeśli dodasz bardzo duży plik, a następnie go usuniesz?

```
RUN dd if=/dev/urandom of=duzyPlik bs=1M count=100
RUN rm duzyPlik
```
Dodanie dużego pliku do obrazu Dockera zwiększy jego rozmiar, ponieważ każda instrukcja w Dockerfile tworzy nową warstwę. Nawet jeśli usuniemy plik w kolejnej instrukcji, warstwa z dodanym plikiem nadal istnieje w historii obrazu. W rezultacie rozmiar końcowego obrazu będzie większy niż oczekiwany, ponieważ zawiera on warstwę z dużym plikiem, mimo że został on usunięty w późniejszej warstwie.

## Jak sobie z tym poradzić?

- Łączenie dodawania i usuwania pliku w jednej instrukcji RUN:

```
RUN dd if=/dev/urandom of=duzyPlik bs=1M count=100 && rm duzyPlik
```
- Używanie wieloetapowego budowania (multi-stage builds), aby przenieść tylko potrzebne pliki do końcowego obrazu.
  
### Stage 1: Build
```
FROM python:3.9 as builder
RUN dd if=/dev/urandom of=duzyPlik bs=1M count=100
```
### Operacje na pliku...

### Stage 2: Runtime
```
FROM python:3.9-slim
COPY --from=builder /app /app
```
